<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript Error Handling with Try-Catch</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        h1 {
            color: #4a5568;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5rem;
        }

        .section {
            margin-bottom: 40px;
            padding: 20px;
            border-radius: 10px;
            background: #f8f9fa;
            border-left: 5px solid #667eea;
        }

        .concept-explanation {
            background: linear-gradient(135deg, #e3f2fd, #bbdefb);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .analogy {
            background: #fff3e0;
            border-left: 4px solid #ff9800;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }

        pre {
            background: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            margin: 15px 0;
        }

        .demo-container {
            background: #f0f4f8;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }

        button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .output {
            background: #1a202c;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 8px;
            font-family: monospace;
            margin-top: 15px;
            min-height: 50px;
            white-space: pre-wrap;
        }

        .error-output {
            color: #fc8181;
        }

        .success-output {
            color: #68d391;
        }

        .warning-output {
            color: #fbd38d;
        }

        .input-group {
            margin: 15px 0;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        input, select {
            padding: 10px;
            border: 2px solid #e2e8f0;
            border-radius: 5px;
            font-size: 16px;
            width: 200px;
        }

        .highlight {
            background-color: #fff59d;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .interactive-section {
            background: linear-gradient(135deg, #f093fb, #f5576c);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üõ°Ô∏è JavaScript Error Handling with Try-Catch</h1>
        
        <!-- Concept Explanation -->
        <div class="concept-explanation">
            <h2>üéØ What is Error Handling?</h2>
            <p><strong>Error handling</strong> is like having a safety net in a circus act. When something goes wrong in your code (like a trapeze artist falling), instead of the whole show crashing down, you catch the error gracefully and handle it appropriately.</p>
            
            <div class="analogy">
                <h4>üé™ Real-World Analogy:</h4>
                <p>Imagine you're cooking dinner and following a recipe:</p>
                <ul>
                    <li><strong>Try:</strong> "Let me try to add salt to the soup"</li>
                    <li><strong>Catch:</strong> "Oops! The salt container is empty - let me use pepper instead"</li>
                    <li><strong>Finally:</strong> "Either way, I'll clean up the kitchen afterward"</li>
                </ul>
            </div>
        </div>

        <!-- Basic Try-Catch Structure -->
        <div class="section">
            <h2>üìã Basic Try-Catch Structure</h2>
            <p>The try-catch block has three main parts:</p>
            
            <pre>try {
    // Code that might throw an error
    console.log("Attempting risky operation...");
    let result = riskyFunction();
} catch (error) {
    // Code to handle the error
    console.log("Something went wrong:", error.message);
} finally {
    // Code that runs regardless of success or failure
    console.log("Cleanup operations");
}</pre>

            <div class="analogy">
                <h4>üèóÔ∏è Construction Analogy:</h4>
                <p><span class="highlight">Try</span> is like attempting to build something risky, <span class="highlight">Catch</span> is your safety protocol when things go wrong, and <span class="highlight">Finally</span> is cleaning up the construction site regardless of success or failure.</p>
            </div>
        </div>

        <!-- Interactive Demo 1: Basic Error Handling -->
        <div class="interactive-section">
            <h2>üß™ Demo 1: Basic Error Handling</h2>
            <p>Let's see try-catch in action with different scenarios:</p>
            
            <div class="demo-container" style="background: rgba(255,255,255,0.9); color: #333;">
                <button onclick="demonstrateSuccess()">‚úÖ Success Case</button>
                <button onclick="demonstrateError()">‚ùå Error Case</button>
                <button onclick="demonstrateFinally()">üîÑ With Finally Block</button>
                
                <div id="basicOutput" class="output"></div>
                
                <h4>Code being executed:</h4>
                <pre>function demonstrateBasicTryCatch(shouldError = false) {
    try {
        console.log("üöÄ Starting operation...");
        
        if (shouldError) {
            throw new Error("Something went wrong!");
        }
        
        console.log("‚úÖ Operation completed successfully!");
        return "Success!";
        
    } catch (error) {
        console.log("‚ùå Caught an error:", error.message);
        return "Error handled gracefully";
        
    } finally {
        console.log("üßπ Cleanup: This always runs");
    }
}</pre>
            </div>
        </div>

        <!-- Different Types of Errors -->
        <div class="section">
            <h2>üîç Types of JavaScript Errors</h2>
            <p>JavaScript has several built-in error types. Think of them as different categories of problems:</p>

            <div class="demo-container">
                <div class="input-group">
                    <label>Select Error Type to Demonstrate:</label>
                    <select id="errorTypeSelect">
                        <option value="syntax">SyntaxError - Wrong grammar</option>
                        <option value="reference">ReferenceError - Using undefined variables</option>
                        <option value="type">TypeError - Wrong data type operations</option>
                        <option value="range">RangeError - Values out of bounds</option>
                        <option value="custom">Custom Error - Your own error types</option>
                    </select>
                </div>
                
                <button onclick="demonstrateErrorType()">üéØ Demonstrate Error</button>
                <div id="errorTypeOutput" class="output"></div>
            </div>

            <pre>// Different error types and when they occur:

// 1. ReferenceError - Using undefined variables
try {
    console.log(undefinedVariable);
} catch (error) {
    console.log("ReferenceError:", error.message);
}

// 2. TypeError - Wrong operations on data types  
try {
    let number = 42;
    number.toUpperCase(); // Numbers don't have toUpperCase method!
} catch (error) {
    console.log("TypeError:", error.message);
}

// 3. RangeError - Values outside acceptable range
try {
    let arr = new Array(-1); // Negative array size!
} catch (error) {
    console.log("RangeError:", error.message);
}

// 4. Custom Errors - Your own error types
try {
    throw new Error("This is my custom error message");
} catch (error) {
    console.log("Custom Error:", error.message);
}</pre>
        </div>

        <!-- Practical Example: Form Validation -->
        <div class="section">
            <h2>üéØ Practical Example: User Input Validation</h2>
            <p>Let's build a real-world example where we validate user input with proper error handling:</p>

            <div class="demo-container">
                <div class="input-group">
                    <label>Enter your age:</label>
                    <input type="text" id="ageInput" placeholder="Enter age (1-120)">
                </div>
                
                <div class="input-group">
                    <label>Enter your email:</label>
                    <input type="text" id="emailInput" placeholder="Enter valid email">
                </div>
                
                <button onclick="validateUserInput()">üîç Validate Input</button>
                <div id="validationOutput" class="output"></div>
            </div>

            <pre>function validateUserInput() {
    const ageInput = document.getElementById('ageInput').value;
    const emailInput = document.getElementById('emailInput').value;
    let validationResults = [];
    
    // Validate age
    try {
        validateAge(ageInput);
        validationResults.push("‚úÖ Age is valid");
    } catch (error) {
        validationResults.push(`‚ùå Age error: ${error.message}`);
    }
    
    // Validate email  
    try {
        validateEmail(emailInput);
        validationResults.push("‚úÖ Email is valid");
    } catch (error) {
        validationResults.push(`‚ùå Email error: ${error.message}`);
    }
    
    return validationResults;
}

function validateAge(age) {
    if (!age || age.trim() === '') {
        throw new Error("Age cannot be empty");
    }
    
    const numAge = Number(age);
    
    if (isNaN(numAge)) {
        throw new Error("Age must be a number");
    }
    
    if (numAge < 1 || numAge > 120) {
        throw new Error("Age must be between 1 and 120");
    }
}

function validateEmail(email) {
    if (!email || email.trim() === '') {
        throw new Error("Email cannot be empty");
    }
    
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    
    if (!emailRegex.test(email)) {
        throw new Error("Email format is invalid");
    }
}</pre>
        </div>

        <!-- Async Error Handling -->
        <div class="section">
            <h2>‚ö° Async/Await Error Handling</h2>
            <p>Modern JavaScript often deals with asynchronous operations (like fetching data from servers). Here's how to handle errors in async functions:</p>

            <div class="demo-container">
                <button onclick="demonstrateAsyncSuccess()">üåê Simulate API Success</button>
                <button onclick="demonstrateAsyncError()">üí• Simulate API Error</button>
                <button onclick="demonstrateAsyncTimeout()">‚è∞ Simulate Timeout</button>
                
                <div id="asyncOutput" class="output"></div>
            </div>

            <div class="analogy">
                <h4>üì´ Postal Service Analogy:</h4>
                <p>Async operations are like sending mail. You send a letter (request) and wait for a response. Sometimes the letter arrives successfully, sometimes it gets lost, and sometimes it takes too long. Try-catch helps you handle all these scenarios.</p>
            </div>

            <pre>// Async/Await with try-catch
async function fetchUserData(userId, shouldFail = false) {
    try {
        console.log(`üì° Fetching data for user ${userId}...`);
        
        // Simulate API call
        const userData = await simulateAPICall(userId, shouldFail);
        
        console.log("‚úÖ Data received:", userData);
        return userData;
        
    } catch (error) {
        console.log("‚ùå Failed to fetch user data:", error.message);
        
        // You might want to return default data or retry
        return { error: true, message: error.message };
        
    } finally {
        console.log("üßπ Cleanup: Closing connection");
    }
}

// Simulate an API call that might fail
function simulateAPICall(userId, shouldFail) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            if (shouldFail) {
                reject(new Error("Network error: Could not reach server"));
            } else {
                resolve({
                    id: userId,
                    name: "John Doe",
                    email: "john@example.com"
                });
            }
        }, 1000); // Simulate 1 second delay
    });
}</pre>
        </div>

        <!-- Best Practices -->
        <div class="section">
            <h2>üí° Best Practices for Error Handling</h2>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                <div style="background: #e8f5e8; padding: 15px; border-radius: 8px;">
                    <h4>‚úÖ Do's</h4>
                    <ul>
                        <li>Be specific with error messages</li>
                        <li>Log errors for debugging</li>
                        <li>Provide fallback solutions</li>
                        <li>Use appropriate error types</li>
                        <li>Clean up resources in finally</li>
                    </ul>
                </div>
                
                <div style="background: #ffeaea; padding: 15px; border-radius: 8px;">
                    <h4>‚ùå Don'ts</h4>
                    <ul>
                        <li>Ignore errors silently</li>
                        <li>Catch all errors the same way</li>
                        <li>Expose sensitive error details</li>
                        <li>Use try-catch for flow control</li>
                        <li>Nest too many try-catch blocks</li>
                    </ul>
                </div>
            </div>

            <pre>// ‚úÖ Good error handling
async function goodErrorHandling() {
    try {
        const data = await riskyOperation();
        return processData(data);
    } catch (error) {
        // Log for developers
        console.error('Operation failed:', error);
        
        // Show user-friendly message
        showUserMessage('Sorry, something went wrong. Please try again.');
        
        // Return safe fallback
        return getDefaultData();
    }
}

// ‚ùå Poor error handling  
async function poorErrorHandling() {
    try {
        const data = await riskyOperation();
        return processData(data);
    } catch (error) {
        // Just swallow the error - BAD!
        console.log('error');
    }
}</pre>
        </div>

        <!-- Summary -->
        <div class="concept-explanation">
            <h2>üéì Summary</h2>
            <p>Error handling with try-catch is like having insurance for your code:</p>
            <ul>
                <li><strong>Try:</strong> Attempt risky operations</li>
                <li><strong>Catch:</strong> Handle errors gracefully when they occur</li>
                <li><strong>Finally:</strong> Perform cleanup regardless of outcome</li>
                <li><strong>Throw:</strong> Create your own errors when needed</li>
            </ul>
            <p>Remember: Good error handling makes your applications robust, user-friendly, and easier to debug! üöÄ</p>
        </div>
    </div>

    <script>
        // Utility function to write to output
        function writeOutput(elementId, message, type = 'normal') {
            const output = document.getElementById(elementId);
            const timestamp = new Date().toLocaleTimeString();
            
            let className = '';
            switch(type) {
                case 'error': className = 'error-output'; break;
                case 'success': className = 'success-output'; break;
                case 'warning': className = 'warning-output'; break;
            }
            
            output.innerHTML = `<span class="${className}">[${timestamp}] ${message}</span>`;
        }

        // Demo 1: Basic try-catch demonstrations
        function demonstrateSuccess() {
            try {
                writeOutput('basicOutput', 'üöÄ Starting operation...\n‚úÖ Operation completed successfully!\nüßπ Cleanup: This always runs', 'success');
            } catch (error) {
                writeOutput('basicOutput', `‚ùå Unexpected error: ${error.message}`, 'error');
            }
        }

        function demonstrateError() {
            try {
                writeOutput('basicOutput', 'üöÄ Starting operation...');
                throw new Error("Something went wrong!");
            } catch (error) {
                writeOutput('basicOutput', `üöÄ Starting operation...\n‚ùå Caught an error: ${error.message}\nüßπ Cleanup: This always runs`, 'warning');
            }
        }

        function demonstrateFinally() {
            let output = '';
            try {
                output += 'üöÄ Starting operation...\n';
                // Randomly succeed or fail
                if (Math.random() > 0.5) {
                    output += '‚úÖ Operation completed successfully!\n';
                } else {
                    throw new Error("Random failure occurred!");
                }
            } catch (error) {
                output += `‚ùå Caught an error: ${error.message}\n`;
            } finally {
                output += 'üßπ Finally block: This ALWAYS executes!';
            }
            writeOutput('basicOutput', output, 'normal');
        }

        // Demo 2: Different error types
        function demonstrateErrorType() {
            const errorType = document.getElementById('errorTypeSelect').value;
            let output = '';

            try {
                switch(errorType) {
                    case 'reference':
                        // This will cause a ReferenceError
                        console.log(undefinedVariable);
                        break;
                    case 'type':
                        // This will cause a TypeError
                        let number = 42;
                        number.toUpperCase();
                        break;
                    case 'range':
                        // This will cause a RangeError
                        let arr = new Array(-1);
                        break;
                    case 'custom':
                        // Custom error
                        throw new Error("This is a custom error message!");
                    case 'syntax':
                        // Note: SyntaxError can't be caught at runtime like this
                        output = "SyntaxError occurs during parsing, before code runs.\nExample: Missing brackets, wrong punctuation, etc.\nIt cannot be caught with try-catch in the same script.";
                        writeOutput('errorTypeOutput', output, 'warning');
                        return;
                }
            } catch (error) {
                output = `Error Type: ${error.constructor.name}\nMessage: ${error.message}\nStatus: ‚úÖ Successfully caught and handled!`;
                writeOutput('errorTypeOutput', output, 'warning');
            }
        }

        // Demo 3: Input validation
        function validateUserInput() {
            const ageInput = document.getElementById('ageInput').value;
            const emailInput = document.getElementById('emailInput').value;
            let results = [];

            // Validate age
            try {
                validateAge(ageInput);
                results.push("‚úÖ Age is valid");
            } catch (error) {
                results.push(`‚ùå Age error: ${error.message}`);
            }

            // Validate email
            try {
                validateEmail(emailInput);
                results.push("‚úÖ Email is valid");
            } catch (error) {
                results.push(`‚ùå Email error: ${error.message}`);
            }

            const output = results.join('\n');
            const hasErrors = results.some(result => result.includes('‚ùå'));
            writeOutput('validationOutput', output, hasErrors ? 'error' : 'success');
        }

        function validateAge(age) {
            if (!age || age.trim() === '') {
                throw new Error("Age cannot be empty");
            }

            const numAge = Number(age);
            if (isNaN(numAge)) {
                throw new Error("Age must be a number");
            }

            if (numAge < 1 || numAge > 120) {
                throw new Error("Age must be between 1 and 120");
            }
        }

        function validateEmail(email) {
            if (!email || email.trim() === '') {
                throw new Error("Email cannot be empty");
            }

            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!emailRegex.test(email)) {
                throw new Error("Email format is invalid");
            }
        }

        // Demo 4: Async error handling
        async function demonstrateAsyncSuccess() {
            try {
                writeOutput('asyncOutput', 'üì° Fetching user data...');
                const userData = await simulateAPICall(123, false);
                writeOutput('asyncOutput', `üì° Fetching user data...\n‚úÖ Success! Received: ${JSON.stringify(userData, null, 2)}\nüßπ Connection closed`, 'success');
            } catch (error) {
                writeOutput('asyncOutput', `‚ùå Error: ${error.message}`, 'error');
            }
        }

        async function demonstrateAsyncError() {
            try {
                writeOutput('asyncOutput', 'üì° Fetching user data...');
                const userData = await simulateAPICall(123, true);
                writeOutput('asyncOutput', `‚úÖ Success: ${JSON.stringify(userData)}`, 'success');
            } catch (error) {
                writeOutput('asyncOutput', `üì° Fetching user data...\n‚ùå Network Error: ${error.message}\nüîÑ Falling back to cached data...\n‚úÖ Using offline mode\nüßπ Connection closed`, 'warning');
            }
        }

        async function demonstrateAsyncTimeout() {
            try {
                writeOutput('asyncOutput', 'üì° Fetching user data with timeout...');
                const userData = await Promise.race([
                    simulateAPICall(123, false, 3000), // 3 second delay
                    new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Request timeout')), 1500) // 1.5 second timeout
                    )
                ]);
                writeOutput('asyncOutput', `‚úÖ Success: ${JSON.stringify(userData)}`, 'success');
            } catch (error) {
                writeOutput('asyncOutput', `üì° Fetching user data with timeout...\n‚ùå Timeout Error: ${error.message}\nüîÑ Retrying with longer timeout...\n‚è∞ Consider checking your connection\nüßπ Connection closed`, 'error');
            }
        }

        function simulateAPICall(userId, shouldFail, delay = 1000) {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    if (shouldFail) {
                        reject(new Error("Network error: Could not reach server"));
                    } else {
                        resolve({
                            id: userId,
                            name: "John Doe",
                            email: "john@example.com",
                            timestamp: new Date().toISOString()
                        });
                    }
                }, delay);
            });
        }
    </script>
</body>
</html>