<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java Method References - Deep Dive</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 2rem;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .content {
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            padding: 2rem;
            margin-bottom: 2rem;
        }

        .section {
            margin-bottom: 2rem;
        }

        .section h2 {
            color: #667eea;
            margin-bottom: 1rem;
            font-size: 1.8rem;
            border-left: 4px solid #667eea;
            padding-left: 1rem;
        }

        .section h3 {
            color: #495057;
            margin-bottom: 0.8rem;
            font-size: 1.3rem;
        }

        .code-block {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            position: relative;
            overflow-x: auto;
        }

        .code-block pre {
            margin: 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .code-block::before {
            content: 'Java';
            position: absolute;
            top: 5px;
            right: 10px;
            background: #667eea;
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
        }

        .highlight {
            background: #fff3cd;
            padding: 1rem;
            border-left: 4px solid #ffc107;
            border-radius: 4px;
            margin: 1rem 0;
        }

        .comparison-box {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin: 1rem 0;
        }

        .comparison-item {
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }

        .lambda-way {
            background: #e7f3ff;
            border-left: 4px solid #007bff;
        }

        .method-ref-way {
            background: #e8f5e8;
            border-left: 4px solid #28a745;
        }

        .info-card {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 10px;
            padding: 1.5rem;
            margin: 1rem 0;
            border-left: 4px solid #667eea;
        }

        .interactive-demo {
            background: #f8f9fa;
            border: 2px solid #667eea;
            border-radius: 10px;
            padding: 1.5rem;
            margin: 1rem 0;
        }

        .demo-button {
            background: #667eea;
            color: white;
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            margin: 0.5rem;
            transition: all 0.3s ease;
        }

        .demo-button:hover {
            background: #5a6fd8;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .output {
            background: #343a40;
            color: #28a745;
            font-family: monospace;
            padding: 1rem;
            border-radius: 5px;
            margin-top: 1rem;
            min-height: 40px;
            white-space: pre-wrap;
        }

        .types-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }

        .type-card {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 1rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .type-card h4 {
            color: #667eea;
            margin-bottom: 0.5rem;
        }

        .syntax-highlight {
            background: #e9ecef;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #495057;
        }

        @media (max-width: 768px) {
            .comparison-box {
                grid-template-columns: 1fr;
            }
            
            .types-grid {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🔗 Method References Deep Dive</h1>
            <p>Understanding how method references work in Java</p>
        </div>

        <div class="content">
            <div class="section">
                <h2>What are Method References?</h2>
                <p>Method references are a shorthand syntax for lambda expressions that simply call an existing method. They make your code more readable and concise when you're just delegating to an existing method.</p>
                
                <div class="highlight">
                    <strong>Key Concept:</strong> Method references use the <span class="syntax-highlight">::</span> operator to refer to a method without actually calling it. The method will be called later when the functional interface is invoked.
                </div>

                <div class="comparison-box">
                    <div class="comparison-item lambda-way">
                        <h4>🔧 Lambda Expression</h4>
                        <div class="code-block">
                            <pre>// Lambda way
Calculator calc = (a, b) -> Integer.sum(a, b);</pre>
                        </div>
                    </div>
                    <div class="comparison-item method-ref-way">
                        <h4>🔗 Method Reference</h4>
                        <div class="code-block">
                            <pre>// Method reference way
Calculator calc = Integer::sum;</pre>
                        </div>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2>How Integer::sum Works</h2>
                <p>Let's break down <code>Integer::sum</code> step by step:</p>
                
                <div class="code-block">
                    <pre>// The Integer.sum method signature:
public static int sum(int a, int b) {
    return a + b;
}

// Your functional interface:
@FunctionalInterface
interface Calculator {
    int calculate(int a, int b);
}

// Method reference magic:
Calculator calc = Integer::sum;

// What happens internally:
// The compiler creates something equivalent to:
Calculator calc = (a, b) -> Integer.sum(a, b);</pre>
                </div>

                <div class="info-card">
                    <h3>🎯 The Magic Behind the Scenes</h3>
                    <ol>
                        <li><strong>Compile-time matching:</strong> Java compiler matches the method signature of <code>Integer.sum(int, int)</code> with the functional interface method <code>calculate(int, int)</code></li>
                        <li><strong>Automatic parameter passing:</strong> The compiler automatically passes the parameters from the interface to the referenced method</li>
                        <li><strong>Return type matching:</strong> Both methods return <code>int</code>, so they're compatible</li>
                        <li><strong>Runtime invocation:</strong> When you call <code>calc.calculate(5, 3)</code>, it actually calls <code>Integer.sum(5, 3)</code></li>
                    </ol>
                </div>
            </div>

            <div class="section">
                <h2>Types of Method References</h2>
                <p>There are four types of method references in Java:</p>

                <div class="types-grid">
                    <div class="type-card">
                        <h4>1. Static Method Reference</h4>
                        <p><span class="syntax-highlight">ClassName::staticMethod</span></p>
                        <div class="code-block">
                            <pre>// Examples:
Integer::sum
Math::max
String::valueOf
Arrays::sort

// Usage:
BinaryOperator&lt;Integer&gt; adder = Integer::sum;
Function&lt;Integer, String&gt; converter = String::valueOf;</pre>
                        </div>
                    </div>

                    <div class="type-card">
                        <h4>2. Instance Method Reference</h4>
                        <p><span class="syntax-highlight">object::instanceMethod</span></p>
                        <div class="code-block">
                            <pre>// Examples:
String str = "Hello";
Supplier&lt;String&gt; upperCase = str::toUpperCase;

System.out::println
list::add
scanner::nextLine</pre>
                        </div>
                    </div>

                    <div class="type-card">
                        <h4>3. Arbitrary Object Method Reference</h4>
                        <p><span class="syntax-highlight">ClassName::instanceMethod</span></p>
                        <div class="code-block">
                            <pre>// Examples:
String::length
String::toUpperCase
Person::getName

// Usage:
Function&lt;String, Integer&gt; lengthGetter = String::length;
// Equivalent to: s -> s.length()</pre>
                        </div>
                    </div>

                    <div class="type-card">
                        <h4>4. Constructor Reference</h4>
                        <p><span class="syntax-highlight">ClassName::new</span></p>
                        <div class="code-block">
                            <pre>// Examples:
ArrayList::new
String::new
Person::new

// Usage:
Supplier&lt;List&lt;String&gt;&gt; listFactory = ArrayList::new;
Function&lt;String, Person&gt; personCreator = Person::new;</pre>
                        </div>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2>Interactive Examples</h2>
                
                <div class="interactive-demo">
                    <h3>🎮 Try Different Method References</h3>
                    <button class="demo-button" onclick="demonstrateStatic()">Static Methods</button>
                    <button class="demo-button" onclick="demonstrateInstance()">Instance Methods</button>
                    <button class="demo-button" onclick="demonstrateArbitrary()">Arbitrary Object</button>
                    <button class="demo-button" onclick="demonstrateConstructor()">Constructor</button>
                    <div class="output" id="methodRefOutput">Click a button to see method references in action!</div>
                </div>
            </div>

            <div class="section">
                <h2>Detailed Breakdown: Integer::sum</h2>
                
                <div class="code-block">
                    <pre>// Step 1: Understanding Integer.sum()
public static int sum(int a, int b) {
    return Math.addExact(a, b); // Handles overflow
}

// Step 2: Your Calculator interface
@FunctionalInterface
interface Calculator {
    int calculate(int a, int b);
    //     ^         ^    ^
    //  return type  |    second parameter
    //            first parameter
}

// Step 3: Method Reference Magic
Calculator calc = Integer::sum;
//                   ^      ^
//                 Class  Method

// Step 4: What the compiler sees
// Method signature match:
// Integer.sum:    (int, int) -> int
// Calculator:     (int, int) -> int
// ✓ PERFECT MATCH!

// Step 5: Usage
int result = calc.calculate(10, 5);
// Internally becomes: Integer.sum(10, 5)
// Returns: 15</pre>
                </div>
            </div>

            <div class="section">
                <h2>Why Use Method References?</h2>
                
                <div class="info-card">
                    <h3>✅ Advantages</h3>
                    <ul>
                        <li><strong>Readability:</strong> More concise and self-documenting than lambda expressions</li>
                        <li><strong>Reusability:</strong> References existing, tested methods rather than writing new code</li>
                        <li><strong>Performance:</strong> Slightly better performance than lambda expressions in some cases</li>
                        <li><strong>Maintainability:</strong> Changes to the referenced method automatically apply everywhere</li>
                        <li><strong>IDE Support:</strong> Better refactoring support from IDEs</li>
                    </ul>
                </div>

                <div class="comparison-box">
                    <div class="comparison-item lambda-way">
                        <h4>❌ Don't Do This</h4>
                        <div class="code-block">
                            <pre>// Verbose lambda
list.stream()
    .map(s -> s.toUpperCase())
    .forEach(s -> System.out.println(s));

// Redundant lambda
numbers.stream()
    .reduce((a, b) -> Integer.sum(a, b));</pre>
                        </div>
                    </div>
                    <div class="comparison-item method-ref-way">
                        <h4>✅ Do This Instead</h4>
                        <div class="code-block">
                            <pre>// Clean method references
list.stream()
    .map(String::toUpperCase)
    .forEach(System.out::println);

// Concise and clear
numbers.stream()
    .reduce(Integer::sum);</pre>
                        </div>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2>Common Pitfalls and Solutions</h2>
                
                <div class="code-block">
                    <pre>// ❌ PITFALL 1: Wrong parameter count
List&lt;String&gt; list = Arrays.asList("a", "b", "c");
// This won't work:
// list.forEach(String::toUpperCase); // toUpperCase() takes no parameters

// ✅ SOLUTION:
list.stream()
    .map(String::toUpperCase)  // This works - transforms each string
    .forEach(System.out::println);

// ❌ PITFALL 2: Mismatched types
Function&lt;String, Integer&gt; parser = Integer::parseInt; // ❌ Won't compile
// parseInt(String, int) exists, but we need parseInt(String)

// ✅ SOLUTION:
Function&lt;String, Integer&gt; parser = Integer::valueOf; // ✅ Works

// ❌ PITFALL 3: Trying to use non-static methods incorrectly
String str = "hello";
Function&lt;String, String&gt; upper = str::toUpperCase; // ❌ Wrong - no parameter

// ✅ SOLUTION:
Supplier&lt;String&gt; upper = str::toUpperCase; // ✅ Correct - no parameter needed</pre>
                </div>
            </div>

            <div class="section">
                <h2>Real-World Example</h2>
                
                <div class="code-block">
                    <pre>import java.util.*;
import java.util.stream.Collectors;

public class MethodReferenceDemo {
    public static void main(String[] args) {
        List&lt;String&gt; names = Arrays.asList(
            "alice", "bob", "charlie", "diana"
        );
        
        // Using method references for clean, readable code
        List&lt;String&gt; processedNames = names.stream()
            .map(String::toUpperCase)           // Transform to uppercase
            .filter(name -> name.length() > 3)  // Keep longer names
            .sorted(String::compareToIgnoreCase) // Sort ignoring case
            .collect(Collectors.toList());      // Collect to list
        
        processedNames.forEach(System.out::println); // Print each
        
        // Custom Calculator using method references
        Calculator calc = Integer::sum;
        int result = calc.calculate(15, 25);
        System.out.println("Sum: " + result); // Output: Sum: 40
        
        // Method reference with custom methods
        List&lt;Person&gt; people = Arrays.asList(
            new Person("John", 25),
            new Person("Jane", 30),
            new Person("Bob", 20)
        );
        
        // Sort by age using method reference
        people.sort(Comparator.comparing(Person::getAge));
        people.forEach(System.out::println);
    }
}

class Person {
    private String name;
    private int age;
    
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public int getAge() { return age; }
    public String getName() { return name; }
    
    @Override
    public String toString() {
        return name + " (" + age + ")";
    }
}</pre>
                </div>
            </div>
        </div>
    </div>

    <script>
        function demonstrateStatic() {
            const output = document.getElementById('methodRefOutput');
            output.innerHTML = `📊 STATIC METHOD REFERENCES

// Integer::sum
BinaryOperator<Integer> adder = Integer::sum;
Result: adder.apply(10, 5) = ${10 + 5}

// Math::max
BinaryOperator<Integer> maxFinder = Math::max;
Result: maxFinder.apply(15, 20) = ${Math.max(15, 20)}

// String::valueOf
Function<Integer, String> converter = String::valueOf;
Result: converter.apply(42) = "${String(42)}"

✨ Key Point: Static method references refer to static methods
   Syntax: ClassName::staticMethodName`;
        }

        function demonstrateInstance() {
            const output = document.getElementById('methodRefOutput');
            const message = "Hello World";
            output.innerHTML = `🎯 INSTANCE METHOD REFERENCES

// Using specific object instance
String message = "${message}";

Supplier<String> upperCaseGetter = message::toUpperCase;
Result: upperCaseGetter.get() = "${message.toUpperCase()}"

Supplier<Integer> lengthGetter = message::length;
Result: lengthGetter.get() = ${message.length}

// System.out::println example
Consumer<String> printer = System.out::println;
// This would print to console when called

✨ Key Point: Instance method references use a specific object
   Syntax: objectInstance::methodName`;
        }

        function demonstrateArbitrary() {
            const output = document.getElementById('methodRefOutput');
            const strings = ["hello", "world", "java"];
            output.innerHTML = `🔄 ARBITRARY OBJECT METHOD REFERENCES

// String::length - works on any String
Function<String, Integer> lengthFunc = String::length;

Testing with different strings:
${strings.map(s => `lengthFunc.apply("${s}") = ${s.length}`).join('\n')}

// String::toUpperCase - works on any String  
Function<String, String> upperFunc = String::toUpperCase;

Testing transformations:
${strings.map(s => `upperFunc.apply("${s}") = "${s.toUpperCase()}"`).join('\n')}

✨ Key Point: The first parameter becomes the object to call the method on
   Syntax: ClassName::instanceMethodName`;
        }

        function demonstrateConstructor() {
            const output = document.getElementById('methodRefOutput');
            output.innerHTML = `🏗️ CONSTRUCTOR REFERENCES

// ArrayList::new
Supplier<List<String>> listFactory = ArrayList::new;
// Creates: new ArrayList<String>()

// Array creation
Function<Integer, String[]> arrayCreator = String[]::new;
// Creates: new String[size]

// Custom object creation
// If you had: Person::new
// Function<String, Person> personFactory = Person::new;
// Creates: new Person(name)

Real example - Creating collections:
List<String> newList = listFactory.get();
// Equivalent to: new ArrayList<String>()

✨ Key Point: Constructor references create new instances
   Syntax: ClassName::new`;
        }
    </script>
</body>
</html>