<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JS Functions - Deep Dive Interactive Demo</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 20px;
        line-height: 1.6;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        background: white;
        border-radius: 15px;
        padding: 40px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      }

      h1 {
        text-align: center;
        color: #667eea;
        margin-bottom: 10px;
        font-size: 2.5em;
      }

      .subtitle {
        text-align: center;
        color: #666;
        margin-bottom: 40px;
        font-style: italic;
      }

      .section {
        margin-bottom: 50px;
        padding: 25px;
        background: #f8f9fa;
        border-radius: 10px;
        border-left: 5px solid #667eea;
      }

      .section h2 {
        color: #764ba2;
        margin-bottom: 15px;
        font-size: 1.8em;
      }

      .concept {
        background: #e3f2fd;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        border-left: 4px solid #2196f3;
      }

      .analogy {
        background: #fff3e0;
        padding: 15px;
        border-radius: 8px;
        margin: 20px 0;
        border-left: 4px solid #ff9800;
      }

      .analogy::before {
        content: "üí° Analogy: ";
        font-weight: bold;
        color: #ff9800;
      }

      pre {
        background: #2d2d2d;
        color: #f8f8f2;
        padding: 20px;
        border-radius: 8px;
        overflow-x: auto;
        margin: 15px 0;
        font-size: 14px;
      }

      code {
        font-family: "Courier New", monospace;
      }

      .demo-box {
        background: white;
        padding: 20px;
        border-radius: 8px;
        margin: 20px 0;
        border: 2px solid #667eea;
      }

      .demo-box h3 {
        color: #667eea;
        margin-bottom: 15px;
      }

      button {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 12px 25px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin: 5px;
        transition: transform 0.2s;
      }

      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
      }

      input,
      select {
        padding: 10px;
        border: 2px solid #ddd;
        border-radius: 5px;
        margin: 5px;
        font-size: 14px;
      }

      input:focus,
      select:focus {
        outline: none;
        border-color: #667eea;
      }

      .output {
        background: #f1f3f4;
        padding: 15px;
        border-radius: 5px;
        margin-top: 15px;
        min-height: 40px;
        font-family: monospace;
      }

      .highlight {
        background: #ffeb3b;
        padding: 2px 5px;
        border-radius: 3px;
      }

      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
        margin: 20px 0;
      }

      .card {
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      .vs-box {
        display: flex;
        gap: 20px;
        margin: 20px 0;
      }

      .vs-item {
        flex: 1;
        padding: 15px;
        border-radius: 8px;
      }

      .vs-item.left {
        background: #e8f5e9;
        border: 2px solid #4caf50;
      }

      .vs-item.right {
        background: #ffebee;
        border: 2px solid #f44336;
      }

      .scope-visualizer {
        position: relative;
        padding: 20px;
        margin: 20px 0;
      }

      .scope-level {
        border: 3px solid;
        padding: 20px;
        margin: 10px;
        border-radius: 8px;
      }

      .scope-global {
        border-color: #ff5722;
        background: rgba(255, 87, 34, 0.1);
      }

      .scope-function {
        border-color: #2196f3;
        background: rgba(33, 150, 243, 0.1);
      }

      .scope-block {
        border-color: #4caf50;
        background: rgba(76, 175, 80, 0.1);
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>üöÄ JavaScript Functions Deep Dive</h1>
      <p class="subtitle">
        Interactive demonstrations for engineering students
      </p>

      <!-- SECTION 1: Function Declarations -->
      <div class="section">
        <h2>1. Function Declarations & Expressions</h2>

        <div class="concept">
          <strong>Quick Concept:</strong> Function declarations are hoisted
          (available before defined), while function expressions are not.
        </div>

        <div class="analogy">
          Think of a function declaration like a government office - it exists
          at a fixed location (address) before you visit it. A function
          expression is like a mobile food stall - it only exists where and when
          it's set up.
        </div>

        <pre><code>// Function Declaration (Hoisted)
function greetDeclaration(name) {
    return `Namaste, ${name}! üôè`;
}

// Function Expression (Not Hoisted) (or) Anonymous Function Expression
const greetExpression = function(name) {
    return `Hello, ${name}! üëã`;
};

</code></pre>

        <div class="demo-box">
          <h3>üéØ Interactive Demo: Try Hoisting</h3>
          <p>
            Click to see the difference between declaration and expression
            hoisting:
          </p>
          <button onclick="demoHoisting()">Test Hoisting Behavior</button>
          <div id="hoistingOutput" class="output"></div>
        </div>

        <div class="demo-box">
          <h3>üéÆ Practice: Create Your Greeting</h3>
          <input type="text" id="userName" placeholder="Enter your name" />
          <button onclick="testDeclaration()">Test Declaration</button>
          <button onclick="testExpression()">Test Expression</button>
          <div id="greetOutput" class="output"></div>
        </div>
      </div>

      <!-- SECTION 2: Parameters and Returns -->
      <div class="section">
        <h2>2. Parameters & Return Values</h2>

        <div class="concept">
          <strong>Quick Concept:</strong> Functions can accept default
          parameters, rest parameters, and return any data type or nothing
          (undefined).
        </div>

        <div class="analogy">
          Parameters are like order forms at a restaurant - you can have default
          options (default parameters), order multiple items as a combo (rest
          parameters), and you get a receipt back (return value). No return? You
          just get a smile (undefined)!
        </div>

        <pre><code>// Default Parameters
function calculateBill(amount, tip = 0.1, tax = 0.05) {
    const total = amount + (amount * tip) + (amount * tax);
    return total.toFixed(2);
}

// Rest Parameters
// Rest Parameters allow us to accept an indefinite number of arguments as an array
// Rest Parameters must be the last parameter in the function definition
function sumGrades(...grades) {
    // grades is an array containing all arguments
    let total = 0;

    // Loop through the array
    for (let i = 0; i < grades.length; i++) {
        total = total + grades[i];
    }

    return total;
}

// Destructured Parameters
function displayStudent({name, rollNo, branch = "CSE"}) {
    return `${name} (${rollNo}) - ${branch}`;
}

// No return (returns undefined)
function logMessage(msg) {
    console.log(msg);
}</code></pre>

        <div class="demo-box">
          <h3>üßÆ Bill Calculator with Default Parameters</h3>
          <input
            type="number"
            id="billAmount"
            placeholder="Bill Amount (‚Çπ)"
            value="1000"
          />
          <input
            type="number"
            id="tipPercent"
            placeholder="Tip % (default 10)"
            step="0.01"
          />
          <input
            type="number"
            id="taxPercent"
            placeholder="Tax % (default 5)"
            step="0.01"
          />
          <button onclick="calculateRestaurantBill()">Calculate Total</button>
          <div id="billOutput" class="output"></div>
        </div>

        <div class="demo-box">
          <h3>üìä Rest Parameters: Sum Multiple Grades</h3>
          <input
            type="text"
            id="gradesInput"
            placeholder="Enter grades separated by commas: 85,90,78,92"
          />
          <button onclick="sumStudentGrades()">
            Calculate Total & Average
          </button>
          <div id="gradesOutput" class="output"></div>
        </div>
      </div>

      <!-- SECTION 3: Arrow Functions -->
      <div class="section">
        <h2>3. Arrow Functions (ES6)</h2>

        <div class="concept">
          <strong>Quick Concept:</strong> Arrow functions provide shorter
          syntax, implicit returns for single expressions, and lexical
          <code>this</code> binding.
        </div>

        <div class="analogy">
          Arrow functions are like speed dial on your phone vs. dialing the full
          number. For simple operations, they're faster to write. But be careful
          - they inherit the caller's context (this), like how a child
          automatically gets their parent's surname!
        </div>

        <pre><code>// Traditional Function
function traditionalMultiply(a, b) {
    return a * b;
}

// Arrow Function - Full Syntax
const arrowMultiply = (a, b) => {
    return a * b;
};

// Arrow Function - Implicit Return
const shortMultiply = (a, b) => a * b;

// Arrow Function - Single Parameter (no parentheses needed)
const square = x => x * x;

// Arrow Function - No Parameters
const getCurrentYear = () => new Date().getFullYear();

// Lexical 'this' Example
const student = {
    name: "Rajesh",
    marks: [85, 90, 78, 92],
    
    // Traditional function - 'this' refers to student object
    getAverageTraditional: function() {
        const sum = this.marks.reduce(function(a, b) {
            return a + b;
        });
        return sum / this.marks.length;
    },
    
    // Arrow function - 'this' is lexically bound to student
    getAverageArrow: function() {
        const sum = this.marks.reduce((a, b) => a + b);
        return sum / this.marks.length;
    }
};</code></pre>

        <div class="vs-box">
          <div class="vs-item left">
            <h4>‚úÖ When to Use Arrow Functions</h4>
            <ul>
              <li>Short callbacks (map, filter, reduce)</li>
              <li>When you need lexical <code>this</code></li>
              <li>Simple one-liner functions</li>
              <li>Functional programming patterns</li>
            </ul>
          </div>
          <div class="vs-item right">
            <h4>‚ùå When NOT to Use Arrow Functions</h4>
            <ul>
              <li>Methods that need their own <code>this</code></li>
              <li>Functions needing <code>arguments</code> object</li>
              <li>Constructor functions</li>
              <li>Event handlers needing element context</li>
            </ul>
          </div>
        </div>

        <div class="demo-box">
          <h3>üéØ Arrow Function Syntax Converter</h3>
          <p>Enter two numbers to see different arrow function syntaxes:</p>
          <input
            type="number"
            id="arrowNum1"
            placeholder="Number 1"
            value="5"
          />
          <input
            type="number"
            id="arrowNum2"
            placeholder="Number 2"
            value="3"
          />
          <button onclick="demoArrowSyntax()">Show All Syntaxes</button>
          <div id="arrowOutput" class="output"></div>
        </div>

        <div class="demo-box">
          <h3>üîó Lexical 'this' Demonstration</h3>
          <button onclick="demoLexicalThis()">Compare 'this' Binding</button>
          <div id="thisOutput" class="output"></div>
        </div>
      </div>

      <!-- SECTION 4: Scope -->
      <div class="section">
        <h2>4. Scope: Global, Function & Block</h2>

        <div class="concept">
          <strong>Quick Concept:</strong> Scope determines where variables are
          accessible. Global scope is everywhere, function scope is within
          functions, block scope (let/const) is within {}.
        </div>

        <div class="analogy">
          Imagine a college campus: <strong>Global scope</strong> is like the
          main ground - everyone can access it.
          <strong>Function scope</strong> is like a classroom - only students
          inside can use the whiteboard. <strong>Block scope</strong> is like a
          lab cubicle - resources are only available within those specific
          walls!
        </div>

        <pre><code>// Global Scope
let campusName = "IIT Bombay"; // Accessible everywhere

function demonstrateScope() {
    // Function Scope
    let className = "Computer Science"; // Only in this function
    
    if (true) {
        // Block Scope
        let studentName = "Priya"; // Only in this block
        const rollNo = "CS101"; // Only in this block
        var oldStyle = "accessible outside"; // var ignores block scope!
        
        console.log(campusName); // ‚úÖ Accessible
        console.log(className); // ‚úÖ Accessible
        console.log(studentName); // ‚úÖ Accessible
    }
    
    console.log(campusName); // ‚úÖ Accessible
    console.log(className); // ‚úÖ Accessible
    // console.log(studentName); // ‚ùå Error! Block-scoped
    console.log(oldStyle); // ‚úÖ var leaked out of block!
}

// console.log(className); // ‚ùå Error! Function-scoped</code></pre>

        <div class="scope-visualizer">
          <div class="scope-level scope-global">
            <strong>üåç Global Scope</strong>
            <p>Variables: accessible everywhere</p>
            <div class="scope-level scope-function">
              <strong>üéØ Function Scope</strong>
              <p>Variables: accessible in function & nested blocks</p>
              <div class="scope-level scope-block">
                <strong>üîí Block Scope (let/const)</strong>
                <p>Variables: only accessible in this block</p>
              </div>
            </div>
          </div>
        </div>

        <div class="demo-box">
          <h3>üîç Scope Explorer</h3>
          <p>
            Click to see which variables are accessible at different scope
            levels:
          </p>
          <button onclick="demoScopeAccess('global')">
            Access from Global
          </button>
          <button onclick="demoScopeAccess('function')">
            Access from Function
          </button>
          <button onclick="demoScopeAccess('block')">Access from Block</button>
          <div id="scopeOutput" class="output"></div>
        </div>

        <div class="demo-box">
          <h3>‚ö†Ô∏è var vs let/const in Loops</h3>
          <button onclick="demoVarLetLoop()">See the Difference</button>
          <div id="loopOutput" class="output"></div>
        </div>
      </div>

      <!-- SECTION 5: Closures -->
      <div class="section">
        <h2>5. Closures (Advanced)</h2>

        <div class="concept">
          <strong>Quick Concept:</strong> A closure is when an inner function
          "remembers" variables from its outer function, even after the outer
          function has finished executing.
        </div>

        <div class="analogy">
          A closure is like a student borrowing a library book. Even after
          leaving the library (outer function completes), the student still has
          access to that book (outer variables) until they return it. The book
          "closes" with the student!
        </div>

        <pre><code>// Simple Closure Example
function createCounter() {
    let count = 0; // Private variable
    
    return function() {
        count++; // Inner function accesses outer variable
        return count;
    };
}

const counter1 = createCounter();
console.log(counter1()); // 1
console.log(counter1()); // 2
console.log(counter1()); // 3

const counter2 = createCounter(); // New closure, independent count
console.log(counter2()); // 1

// Practical Example: Bank Account
function createBankAccount(initialBalance) {
    let balance = initialBalance; // Private
    
    return {
        deposit: function(amount) {
            balance += amount;
            return `Deposited ‚Çπ${amount}. New balance: ‚Çπ${balance}`;
        },
        withdraw: function(amount) {
            if (amount > balance) {
                return "Insufficient funds!";
            }
            balance -= amount;
            return `Withdrew ‚Çπ${amount}. Remaining: ‚Çπ${balance}`;
        },
        checkBalance: function() {
            return `Current balance: ‚Çπ${balance}`;
        }
    };
}</code></pre>

        <div class="demo-box">
          <h3>üè¶ Interactive Bank Account (Closure Demo)</h3>
          <button onclick="createNewAccount()">
            Create New Account (‚Çπ5000)
          </button>
          <div style="margin-top: 15px">
            <input
              type="number"
              id="accountAmount"
              placeholder="Amount"
              value="500"
            />
            <button onclick="depositMoney()">Deposit</button>
            <button onclick="withdrawMoney()">Withdraw</button>
            <button onclick="checkBalance()">Check Balance</button>
          </div>
          <div id="accountOutput" class="output"></div>
        </div>

        <div class="demo-box">
          <h3>üéÆ Multiple Independent Counters</h3>
          <button onclick="createNewCounter()">Create New Counter</button>
          <div id="countersContainer" style="margin-top: 15px"></div>
        </div>
      </div>

      <!-- SECTION 6: Higher-Order Functions -->
      <div class="section">
        <h2>6. Higher-Order Functions</h2>

        <div class="concept">
          <strong>Quick Concept:</strong> Functions that accept other functions
          as arguments or return functions. Essential for functional programming
          patterns.
        </div>

        <div class="analogy">
          A higher-order function is like a professor who assigns project work
          (passes work as a function) to students. The professor doesn't do the
          work but orchestrates it. Or like a factory (function) that creates
          other machines (functions)!
        </div>

        <pre><code>// Higher-Order Function Example 1: Function as Argument
function processArray(arr, operation) {
    const results = [];
    for (let item of arr) {
        results.push(operation(item));
    }
    return results;
}

const numbers = [1, 2, 3, 4, 5];
const doubled = processArray(numbers, x => x * 2);
const squared = processArray(numbers, x => x * x);

// Higher-Order Function Example 2: Function Returns Function
function createMultiplier(multiplier) {
    return function(number) {
        return number * multiplier;
    };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);
console.log(double(5)); // 10
console.log(triple(5)); // 15

// Real-world Example: API Request Wrapper
function withLogging(fn) {
    return function(...args) {
        console.log(`Calling function with args: ${args}`);
        const result = fn(...args);
        console.log(`Result: ${result}`);
        return result;
    };
}

const add = (a, b) => a + b;
const loggedAdd = withLogging(add);
loggedAdd(5, 3); // Logs the process</code></pre>

        <div class="demo-box">
          <h3>üîß Array Transformer</h3>
          <input
            type="text"
            id="hofArray"
            placeholder="Enter numbers (comma-separated): 1,2,3,4,5"
            value="1,2,3,4,5"
          />
          <select id="hofOperation">
            <option value="double">Double (x * 2)</option>
            <option value="square">Square (x¬≤)</option>
            <option value="cube">Cube (x¬≥)</option>
            <option value="sqrt">Square Root (‚àöx)</option>
          </select>
          <button onclick="transformArray()">Transform</button>
          <div id="hofOutput" class="output"></div>
        </div>

        <div class="demo-box">
          <h3>üéõÔ∏è Function Factory</h3>
          <p>Create custom multiplier functions:</p>
          <input
            type="number"
            id="multiplierValue"
            placeholder="Multiplier value"
            value="5"
          />
          <button onclick="createCustomMultiplier()">Create Multiplier</button>
          <div style="margin-top: 15px">
            <input
              type="number"
              id="numberToMultiply"
              placeholder="Number to multiply"
              value="7"
            />
            <button onclick="useCustomMultiplier()">Apply Multiplier</button>
          </div>
          <div id="multiplierOutput" class="output"></div>
        </div>
      </div>

      <!-- SECTION 7: IIFE -->
      <div class="section">
        <h2>7. IIFE (Immediately Invoked Function Expression)</h2>

        <div class="concept">
          <strong>Quick Concept:</strong> A function that runs immediately after
          being defined, creating a private scope without polluting global
          namespace.
        </div>

        <div class="analogy">
          An IIFE is like a pop-up shop during a festival - it sets up,
          operates, and closes down immediately. It doesn't leave any permanent
          structures (variables) behind in the public space (global scope)!
        </div>

        <pre><code>// Basic IIFE Syntax
(function() {
    console.log("I run immediately!");
})();

// IIFE with Parameters
(function(name, city) {
    console.log(`Hello ${name} from ${city}!`);
})("Rajesh", "Bangalore");

// Arrow Function IIFE
(() => {
    console.log("Arrow IIFE!");
})();

// IIFE Returning Value
const result = (function(a, b) {
    return a + b;
})(5, 3);

// Practical Use: Creating Private Variables
const calculator = (function() {
    let operationCount = 0; // Private
    
    return {
        add: function(a, b) {
            operationCount++;
            return a + b;
        },
        getOperationCount: function() {
            return operationCount;
        }
    };
})();</code></pre>

        <div class="demo-box">
          <h3>üé™ IIFE Demo: Private Counter Module</h3>
          <button onclick="iifeAdd()">Add Two Numbers</button>
          <button onclick="iifeMultiply()">Multiply Two Numbers</button>
          <button onclick="iifeGetCount()">Get Operation Count</button>
          <div id="iifeOutput" class="output"></div>
        </div>
      </div>

      <!-- SECTION 8: Callback Functions -->
      <div class="section">
        <h2>8. Callback Functions</h2>

        <div class="concept">
          <strong>Quick Concept:</strong> Functions passed as arguments to other
          functions, to be executed later (often after an async operation
          completes).
        </div>

        <div class="analogy">
          A callback is like giving your phone number to a restaurant for a
          takeaway order. You do other things, and they "call you back" when the
          food is ready. You don't wait there blocking everything else!
        </div>

        <pre><code>// Simple Callback Example
function greetUser(name, callback) {
    const message = `Welcome ${name}!`;
    callback(message);
}

greetUser("Priya", function(msg) {
    console.log(msg);
});

// Array Methods with Callbacks
const students = ["Amit", "Bina", "Chetan", "Divya"];

students.forEach(function(student) {
    console.log(`Hello ${student}`);
});

// Simulating Async Operation
function fetchUserData(userId, callback) {
    console.log("Fetching user data...");
    setTimeout(function() {
        const userData = {
            id: userId,
            name: "Rajesh Kumar",
            email: "rajesh@example.com"
        };
        callback(userData);
    }, 2000);
}</code></pre>

        <div class="demo-box">
          <h3>‚è±Ô∏è Simulated Async Operation</h3>
          <p>Click to simulate fetching student data (2 second delay):</p>
          <button onclick="simulateAsyncFetch()">Fetch Student Data</button>
          <div id="callbackOutput" class="output">Waiting for action...</div>
        </div>

        <div class="demo-box">
          <h3>üìã Array Methods with Callbacks</h3>
          <input
            type="text"
            id="callbackArray"
            placeholder="Names (comma-separated)"
            value="Amit,Priya,Raj,Sneha"
          />
          <button onclick="demoArrayCallbacks()">Process Array</button>
          <div id="arrayCallbackOutput" class="output"></div>
        </div>
      </div>
    </div>

    <script>
      // SECTION 1: Hoisting Demo
      function demoHoisting() {
        const output = document.getElementById("hoistingOutput");
        let result = "<strong>Testing Hoisting:</strong><br><br>";

        try {
          // This works because declarations are hoisted
          result +=
            "‚úÖ Declaration (hoisted): " + testDeclarationHoist() + "<br>";
        } catch (e) {
          result += "‚ùå Error: " + e.message + "<br>";
        }

        try {
          // This fails because expressions are not hoisted
          result +=
            "‚úÖ Expression (not hoisted): " + testExpressionHoist() + "<br>";
        } catch (e) {
          result += "‚ùå Expression Error: " + e.message + "<br>";
        }

        result +=
          "<br><em>Function declarations are available throughout their scope, even before definition!</em>";
        output.innerHTML = result;
      }

      function testDeclarationHoist() {
        return hoistedFunction(); // Called before definition - works!

        function hoistedFunction() {
          return "I'm hoisted! üöÄ";
        }
      }

      function testExpressionHoist() {
        return notHoistedFunction(); // Called before definition - fails!

        const notHoistedFunction = function () {
          return "I'm not hoisted! ‚ùå";
        };
      }

      function testDeclaration() {
        const name = document.getElementById("userName").value || "Guest";
        const output = document.getElementById("greetOutput");

        function greetDeclaration(name) {
          return `Namaste, ${name}! üôè`;
        }

        output.innerHTML =
          "<strong>Declaration Result:</strong> " + greetDeclaration(name);
      }

      function testExpression() {
        const name = document.getElementById("userName").value || "Guest";
        const output = document.getElementById("greetOutput");

        const greetExpression = function (name) {
          return `Hello, ${name}! üëã`;
        };

        output.innerHTML =
          "<strong>Expression Result:</strong> " + greetExpression(name);
      }

      // SECTION 2: Parameters and Returns
      function calculateRestaurantBill() {
        const amount =
          parseFloat(document.getElementById("billAmount").value) || 1000;
        const tip =
          parseFloat(document.getElementById("tipPercent").value) || 10;
        const tax =
          parseFloat(document.getElementById("taxPercent").value) || 5;
        const output = document.getElementById("billOutput");

        function calculateBill(amount, tipPercent = 10, taxPercent = 5) {
          const tipAmount = amount * (tipPercent / 100);
          const taxAmount = amount * (taxPercent / 100);
          const total = amount + tipAmount + taxAmount;
          return {
            base: amount.toFixed(2),
            tip: tipAmount.toFixed(2),
            tax: taxAmount.toFixed(2),
            total: total.toFixed(2),
          };
        }

        const bill = calculateBill(amount, tip, tax);
        output.innerHTML = `
                <strong>Bill Breakdown:</strong><br>
                Base Amount: ‚Çπ${bill.base}<br>
                Tip (${tip}%): ‚Çπ${bill.tip}<br>
                Tax (${tax}%): ‚Çπ${bill.tax}<br>
                <strong>Total: ‚Çπ${bill.total}</strong><br><br>
                <em>Default values used: Tip=${tip}%, Tax=${tax}%</em>
            `;
      }

      function sumStudentGrades() {
        const gradesInput = document.getElementById("gradesInput").value;
        const output = document.getElementById("gradesOutput");

        if (!gradesInput.trim()) {
          output.innerHTML =
            '<span style="color: red;">Please enter some grades!</span>';
          return;
        }

        const grades = gradesInput
          .split(",")
          .map((g) => parseFloat(g.trim()))
          .filter((g) => !isNaN(g));

        function sumGrades(...grades) {
          return grades.reduce((sum, grade) => sum + grade, 0);
        }

        function calculateAverage(...grades) {
          return grades.length > 0 ? sumGrades(...grades) / grades.length : 0;
        }

        const total = sumGrades(...grades);
        const average = calculateAverage(...grades);

        output.innerHTML = `
                <strong>Grades Entered:</strong> ${grades.join(", ")}<br>
                <strong>Total Grades:</strong> ${grades.length}<br>
                <strong>Sum:</strong> ${total.toFixed(2)}<br>
                <strong>Average:</strong> ${average.toFixed(2)}<br><br>
                <em>Using rest parameters (...grades) to accept unlimited arguments!</em>
            `;
      }

      // SECTION 3: Arrow Functions
      function demoArrowSyntax() {
        const num1 =
          parseFloat(document.getElementById("arrowNum1").value) || 5;
        const num2 =
          parseFloat(document.getElementById("arrowNum2").value) || 3;
        const output = document.getElementById("arrowOutput");

        // Different arrow function syntaxes
        const multiply1 = (a, b) => {
          return a * b;
        };

        const multiply2 = (a, b) => a * b;

        const square = (x) => x * x;

        const getSum = () => num1 + num2;

        output.innerHTML = `
                <strong>Results for ${num1} and ${num2}:</strong><br><br>
                <code>const multiply = (a, b) => { return a * b; }</code><br>
                Result: ${multiply1(num1, num2)}<br><br>
                
                <code>const multiply = (a, b) => a * b;</code> (implicit return)<br>
                Result: ${multiply2(num1, num2)}<br><br>
                
                <code>const square = x => x * x;</code> (single param, no parens)<br>
                Result: ${square(num1)}<br><br>
                
                <code>const getSum = () => num1 + num2;</code> (no params)<br>
                Result: ${getSum()}<br>
            `;
      }

      function demoLexicalThis() {
        const output = document.getElementById("thisOutput");

        const student = {
          name: "Anjali",
          marks: [85, 90, 78, 92, 88],

          getAverageTraditional: function () {
            let sum = 0;
            // Traditional function in forEach - 'this' context is lost!
            this.marks.forEach(function (mark) {
              sum += mark;
            });
            return (sum / this.marks.length).toFixed(2);
          },

          getAverageArrow: function () {
            // Arrow function maintains 'this' context
            const sum = this.marks.reduce((acc, mark) => acc + mark, 0);
            return (sum / this.marks.length).toFixed(2);
          },

          displayInfo: function () {
            // Arrow function in setTimeout maintains 'this'
            setTimeout(() => {
              return `${this.name}'s marks: ${this.marks.join(", ")}`;
            }, 0);
          },
        };

        output.innerHTML = `
                <strong>Student:</strong> ${student.name}<br>
                <strong>Marks:</strong> ${student.marks.join(", ")}<br><br>
                
                <strong>Using Arrow Function (‚úÖ Lexical 'this'):</strong><br>
                Average: ${student.getAverageArrow()}<br><br>
                
                <em>Arrow functions inherit 'this' from their enclosing scope, making them perfect for callbacks where you need to maintain context!</em>
            `;
      }

      // SECTION 4: Scope
      function demoScopeAccess(level) {
        const output = document.getElementById("scopeOutput");
        let result = `<strong>Accessing variables from ${level.toUpperCase()} scope:</strong><br><br>`;

        // Simulate scope levels
        let globalVar = "üåç Global Variable";

        function outerFunction() {
          let functionVar = "üéØ Function Variable";

          if (true) {
            let blockVar = "üîí Block Variable";
            const blockConst = "üîí Block Constant";
            var leakyVar = "‚ö†Ô∏è Var (leaks out of block)";

            if (level === "block") {
              result += `‚úÖ globalVar: "${globalVar}"<br>`;
              result += `‚úÖ functionVar: "${functionVar}"<br>`;
              result += `‚úÖ blockVar: "${blockVar}"<br>`;
              result += `‚úÖ blockConst: "${blockConst}"<br>`;
              result += `‚úÖ leakyVar: "${leakyVar}"<br>`;
            }
          }

          if (level === "function") {
            result += `‚úÖ globalVar: "${globalVar}"<br>`;
            result += `‚úÖ functionVar: "${functionVar}"<br>`;
            result += `‚ùå blockVar: ReferenceError - not accessible!<br>`;
            result += `‚ùå blockConst: ReferenceError - not accessible!<br>`;
            result += `‚úÖ leakyVar: "${leakyVar}" (var leaked out!)<br>`;
          }
        }

        if (level === "global") {
          result += `‚úÖ globalVar: "${globalVar}"<br>`;
          result += `‚ùå functionVar: ReferenceError - not accessible!<br>`;
          result += `‚ùå blockVar: ReferenceError - not accessible!<br>`;
        } else {
          outerFunction();
        }

        output.innerHTML = result;
      }

      function demoVarLetLoop() {
        const output = document.getElementById("loopOutput");
        let result = "<strong>Comparing var vs let in loops:</strong><br><br>";

        // Using var
        result += "<strong>Using var:</strong><br>";
        const varButtons = [];
        for (var i = 0; i < 3; i++) {
          varButtons.push(() => i); // All will reference same 'i'
        }
        result += "Button 0 logs: " + varButtons[0]() + "<br>";
        result += "Button 1 logs: " + varButtons[1]() + "<br>";
        result += "Button 2 logs: " + varButtons[2]() + "<br>";
        result += "<em>All show 3 because var is function-scoped!</em><br><br>";

        // Using let
        result += "<strong>Using let:</strong><br>";
        const letButtons = [];
        for (let j = 0; j < 3; j++) {
          letButtons.push(() => j); // Each has its own 'j'
        }
        result += "Button 0 logs: " + letButtons[0]() + "<br>";
        result += "Button 1 logs: " + letButtons[1]() + "<br>";
        result += "Button 2 logs: " + letButtons[2]() + "<br>";
        result +=
          "<em>Each shows correct value because let is block-scoped!</em>";

        output.innerHTML = result;
      }

      // SECTION 5: Closures
      let currentAccount = null;

      function createNewAccount() {
        function createBankAccount(initialBalance) {
          let balance = initialBalance;

          return {
            deposit: function (amount) {
              balance += amount;
              return `Deposited ‚Çπ${amount}. New balance: ‚Çπ${balance}`;
            },
            withdraw: function (amount) {
              if (amount > balance) {
                return "‚ùå Insufficient funds!";
              }
              balance -= amount;
              return `Withdrew ‚Çπ${amount}. Remaining: ‚Çπ${balance}`;
            },
            checkBalance: function () {
              return `Current balance: ‚Çπ${balance}`;
            },
          };
        }

        currentAccount = createBankAccount(5000);
        document.getElementById("accountOutput").innerHTML =
          "<strong>‚úÖ New account created with ‚Çπ5000!</strong><br>Try deposit/withdraw operations.";
      }

      function depositMoney() {
        if (!currentAccount) {
          document.getElementById("accountOutput").innerHTML =
            '<span style="color: red;">Please create an account first!</span>';
          return;
        }
        const amount =
          parseFloat(document.getElementById("accountAmount").value) || 0;
        document.getElementById("accountOutput").innerHTML =
          currentAccount.deposit(amount);
      }

      function withdrawMoney() {
        if (!currentAccount) {
          document.getElementById("accountOutput").innerHTML =
            '<span style="color: red;">Please create an account first!</span>';
          return;
        }
        const amount =
          parseFloat(document.getElementById("accountAmount").value) || 0;
        document.getElementById("accountOutput").innerHTML =
          currentAccount.withdraw(amount);
      }

      function checkBalance() {
        if (!currentAccount) {
          document.getElementById("accountOutput").innerHTML =
            '<span style="color: red;">Please create an account first!</span>';
          return;
        }
        document.getElementById("accountOutput").innerHTML =
          currentAccount.checkBalance();
      }

      let counterInstances = [];

      function createNewCounter() {
        function createCounter() {
          let count = 0;
          return function () {
            count++;
            return count;
          };
        }

        const newCounter = createCounter();
        const counterId = counterInstances.length;
        counterInstances.push(newCounter);

        const container = document.getElementById("countersContainer");
        const counterDiv = document.createElement("div");
        counterDiv.style.cssText =
          "background: #e3f2fd; padding: 10px; margin: 5px; border-radius: 5px;";
        counterDiv.innerHTML = `
                <strong>Counter ${counterId + 1}:</strong> 
                <button onclick="incrementCounter(${counterId})">Increment</button>
                <span id="counter${counterId}">0</span>
            `;
        container.appendChild(counterDiv);
      }

      function incrementCounter(id) {
        const newValue = counterInstances[id]();
        document.getElementById(`counter${id}`).textContent = newValue;
      }

      // SECTION 6: Higher-Order Functions
      function transformArray() {
        const input = document.getElementById("hofArray").value;
        const operation = document.getElementById("hofOperation").value;
        const output = document.getElementById("hofOutput");

        const numbers = input
          .split(",")
          .map((n) => parseFloat(n.trim()))
          .filter((n) => !isNaN(n));

        function processArray(arr, fn) {
          return arr.map(fn);
        }

        let result;
        let operationDesc;

        switch (operation) {
          case "double":
            result = processArray(numbers, (x) => x * 2);
            operationDesc = "x * 2";
            break;
          case "square":
            result = processArray(numbers, (x) => x * x);
            operationDesc = "x¬≤";
            break;
          case "cube":
            result = processArray(numbers, (x) => x * x * x);
            operationDesc = "x¬≥";
            break;
          case "sqrt":
            result = processArray(numbers, (x) => Math.sqrt(x).toFixed(2));
            operationDesc = "‚àöx";
            break;
        }

        output.innerHTML = `
                <strong>Input:</strong> [${numbers.join(", ")}]<br>
                <strong>Operation:</strong> ${operationDesc}<br>
                <strong>Output:</strong> [${result.join(", ")}]<br><br>
                <em>Higher-order function processArray() accepts operation as parameter!</em>
            `;
      }

      let customMultiplier = null;

      function createCustomMultiplier() {
        const multiplier =
          parseFloat(document.getElementById("multiplierValue").value) || 1;

        function createMultiplier(mult) {
          return function (number) {
            return number * mult;
          };
        }

        customMultiplier = createMultiplier(multiplier);
        document.getElementById("multiplierOutput").innerHTML =
          `<strong>‚úÖ Created multiplier function (x${multiplier})</strong><br>Now enter a number to multiply!`;
      }

      function useCustomMultiplier() {
        if (!customMultiplier) {
          document.getElementById("multiplierOutput").innerHTML =
            '<span style="color: red;">Please create a multiplier first!</span>';
          return;
        }
        const number =
          parseFloat(document.getElementById("numberToMultiply").value) || 0;
        const result = customMultiplier(number);
        document.getElementById("multiplierOutput").innerHTML =
          `<strong>Result:</strong> ${result}<br><em>Function returned by createMultiplier() remembered the multiplier value!</em>`;
      }

      // SECTION 7: IIFE
      const iifeCalculator = (function () {
        let operationCount = 0; // Private variable

        return {
          add: function (a, b) {
            operationCount++;
            return { result: a + b, count: operationCount };
          },
          multiply: function (a, b) {
            operationCount++;
            return { result: a * b, count: operationCount };
          },
          getCount: function () {
            return operationCount;
          },
        };
      })();

      function iifeAdd() {
        const result = iifeCalculator.add(5, 3);
        document.getElementById("iifeOutput").innerHTML =
          `<strong>5 + 3 = ${result.result}</strong><br>Operations performed: ${result.count}`;
      }

      function iifeMultiply() {
        const result = iifeCalculator.multiply(4, 7);
        document.getElementById("iifeOutput").innerHTML =
          `<strong>4 √ó 7 = ${result.result}</strong><br>Operations performed: ${result.count}`;
      }

      function iifeGetCount() {
        const count = iifeCalculator.getCount();
        document.getElementById("iifeOutput").innerHTML =
          `<strong>Total operations performed: ${count}</strong><br><em>operationCount is private - can't be accessed directly!</em>`;
      }

      // SECTION 8: Callbacks
      function simulateAsyncFetch() {
        const output = document.getElementById("callbackOutput");
        output.innerHTML = "‚è≥ Fetching student data from server...";

        function fetchUserData(userId, callback) {
          setTimeout(function () {
            const userData = {
              id: userId,
              name: "Priya Sharma",
              email: "priya.sharma@example.com",
              branch: "Computer Science",
              year: "3rd Year",
            };
            callback(userData);
          }, 2000);
        }

        fetchUserData(12345, function (data) {
          output.innerHTML = `
                    <strong>‚úÖ Data fetched successfully!</strong><br><br>
                    <strong>Name:</strong> ${data.name}<br>
                    <strong>Email:</strong> ${data.email}<br>
                    <strong>Branch:</strong> ${data.branch}<br>
                    <strong>Year:</strong> ${data.year}<br><br>
                    <em>Callback function executed after async operation completed!</em>
                `;
        });
      }

      function demoArrayCallbacks() {
        const input = document.getElementById("callbackArray").value;
        const output = document.getElementById("arrayCallbackOutput");

        const names = input
          .split(",")
          .map((n) => n.trim())
          .filter((n) => n);

        let result = "<strong>Array Method Callbacks:</strong><br><br>";

        // forEach
        result += "<strong>1. forEach() - Iterate & Display:</strong><br>";
        names.forEach(function (name, index) {
          result += `${index + 1}. Hello ${name}!<br>`;
        });

        // map
        result += "<br><strong>2. map() - Transform to Uppercase:</strong><br>";
        const uppercase = names.map((name) => name.toUpperCase());
        result += uppercase.join(", ") + "<br>";

        // filter
        result +=
          "<br><strong>3. filter() - Names with 5+ letters:</strong><br>";
        const longNames = names.filter((name) => name.length >= 5);
        result += longNames.join(", ") + "<br>";

        // find
        result +=
          '<br><strong>4. find() - First name starting with "R":</strong><br>';
        const foundName = names.find((name) =>
          name.toLowerCase().startsWith("r"),
        );
        result += (foundName || "None found") + "<br>";

        output.innerHTML = result;
      }
    </script>
  </body>
</html>
